{"version":3,"file":"AriaLabelHelper.e3d1fa46.mjs","sources":["../node_modules/@ui5/webcomponents-base/dist/util/AriaLabelHelper.js"],"sourcesContent":["const associatedElements = new WeakMap();\nconst registeredElements = new WeakMap();\nconst observerOptions = {\n    attributes: true,\n    childList: true,\n    characterData: true,\n    subtree: true,\n};\nconst getEffectiveAriaLabelText = (el) => {\n    const accessibleEl = el;\n    if (!accessibleEl.accessibleNameRef) {\n        if (accessibleEl.accessibleName) {\n            return accessibleEl.accessibleName;\n        }\n        return undefined;\n    }\n    return getAllAccessibleNameRefTexts(el);\n};\n/**\n *\n * @param {HTMLElement} el Defines the HTMLElement, for which you need to get all related texts\n */\nconst getAllAccessibleNameRefTexts = (el) => {\n    const ids = el.accessibleNameRef?.split(\" \") ?? [];\n    const owner = el.getRootNode();\n    let result = \"\";\n    ids.forEach((elementId, index) => {\n        const element = owner.querySelector(`[id='${elementId}']`);\n        const text = `${element && element.textContent ? element.textContent : \"\"}`;\n        if (text) {\n            result += text;\n            if (index < ids.length - 1) {\n                result += \" \";\n            }\n        }\n    });\n    return result;\n};\nconst _getAllAssociatedElementsFromDOM = (el) => {\n    const set = new Set();\n    // adding labels with attribute for matching the el.id\n    const labelsForAssociated = _getAssociatedLabels(el);\n    labelsForAssociated.forEach(itm => {\n        set.add(itm);\n    });\n    // adding other elements that id is the same as accessibleNameRef value\n    const value = el[\"accessibleNameRef\"];\n    const ids = value?.split(\" \") ?? [];\n    ids.forEach(id => {\n        const refEl = _getReferencedElementById(el, id);\n        if (refEl) {\n            set.add(refEl);\n        }\n    });\n    return Array.from(set);\n};\nconst _getAssociatedLabels = (el) => {\n    const labels = el.getRootNode().querySelectorAll(`[for=\"${el.id}\"]`);\n    return Array.from(labels);\n};\nconst _getReferencedElementById = (el, elementId) => {\n    return el.getRootNode().querySelector(`[id='${elementId}']`);\n};\n/**\n * @param {HTMLElement} el Defines the HTMLElement, for which you need to get all related \"label for\" texts\n */\nconst getAssociatedLabelForTexts = (el) => {\n    const results = [];\n    const labels = _getAssociatedLabels(el);\n    labels.forEach((label) => {\n        const labelText = label.textContent;\n        labelText && results.push(labelText);\n    });\n    if (results.length) {\n        return results.join(\" \");\n    }\n    return undefined;\n};\nconst _createInvalidationCallback = (el) => {\n    const invalidationCallback = (changeInfo) => {\n        if (!(changeInfo && changeInfo.type === \"property\" && changeInfo.name === \"accessibleNameRef\")) {\n            return;\n        }\n        const registeredElement = registeredElements.get(el);\n        if (!registeredElement) {\n            return;\n        }\n        const oldAssociatedElements = registeredElement.observedElements;\n        const newAssociatedElements = _getAllAssociatedElementsFromDOM(el);\n        oldAssociatedElements.forEach(oldElement => {\n            if (!newAssociatedElements.includes(oldElement)) {\n                _removeObservedElementFromRegisteredElement(registeredElement, oldElement);\n            }\n        });\n        newAssociatedElements.forEach(newElement => {\n            if (!oldAssociatedElements.includes(newElement)) {\n                _addObservedElementToRegisteredElement(registeredElement, newElement);\n                registeredElement.observedElements.push(newElement);\n            }\n        });\n        registeredElement?.callback();\n    };\n    return invalidationCallback;\n};\nconst registerUI5Element = (el, callback) => {\n    if (registeredElements.has(el)) {\n        return;\n    }\n    const allAssociatedElements = _getAllAssociatedElementsFromDOM(el);\n    const invalidationCallback = _createInvalidationCallback(el);\n    const registeredElement = {\n        host: el,\n        observedElements: allAssociatedElements,\n        callback,\n        invalidationCallback,\n    };\n    registeredElements.set(el, registeredElement);\n    el.attachInvalidate(invalidationCallback);\n    allAssociatedElements.forEach((element) => {\n        _addObservedElementToRegisteredElement(registeredElement, element);\n    });\n    callback();\n};\nconst _addObservedElementToRegisteredElement = (registeredElement, element) => {\n    let associatedElement = associatedElements.get(element);\n    if (!associatedElement) {\n        associatedElement = { observer: null, callbacks: [] };\n        const observer = new MutationObserver(() => {\n            const callbacks = associatedElement.callbacks;\n            callbacks.forEach(callback => {\n                callback();\n            });\n            const domEl = document.getElementById(element.id);\n            // if no longer should be observed from this registeredElement, remove it\n            if (!(registeredElement.host.id === element.getAttribute(\"for\") || domEl)) {\n                _removeObservedElementFromRegisteredElement(registeredElement, element);\n            }\n        });\n        associatedElement.observer = observer;\n        observer.observe(element, observerOptions);\n        associatedElements.set(element, associatedElement);\n    }\n    if (!associatedElement.callbacks.includes(registeredElement.callback)) {\n        associatedElement.callbacks.push(registeredElement.callback);\n    }\n};\nconst _removeObservedElementFromRegisteredElement = (registeredElement, element) => {\n    const associatedElement = associatedElements.get(element);\n    if (associatedElement) {\n        associatedElement.callbacks = associatedElement.callbacks.filter(itm => itm !== registeredElement.callback);\n        if (!associatedElement.callbacks.length) {\n            associatedElement.observer?.disconnect();\n            associatedElements.delete(element);\n        }\n    }\n    registeredElement.observedElements = registeredElement.observedElements.filter(itm => itm !== element);\n};\nconst deregisterUI5Element = (el) => {\n    const registeredElement = registeredElements.get(el);\n    if (!registeredElement) {\n        return;\n    }\n    const oldObservedElements = [...registeredElement.observedElements];\n    oldObservedElements.forEach(observedElement => {\n        _removeObservedElementFromRegisteredElement(registeredElement, observedElement);\n    });\n    el.detachInvalidate(registeredElement.invalidationCallback);\n    registeredElements.delete(el);\n};\nexport { getEffectiveAriaLabelText, getAssociatedLabelForTexts, registerUI5Element, deregisterUI5Element, getAllAccessibleNameRefTexts, };\n//# sourceMappingURL=AriaLabelHelper.js.map"],"names":["getEffectiveAriaLabelText","el","accessibleEl","getAllAccessibleNameRefTexts","_a","_b","ids","owner","result","elementId","index","element","text"],"mappings":"AAQK,MAACA,IAA4B,CAACC,MAAO;AACtC,QAAMC,IAAeD;AACrB,SAAKC,EAAa,oBAMXC,EAA6BF,CAAE,IAL9BC,EAAa,iBACNA,EAAa,iBAExB;AAGR,GAKMC,IAA+B,CAACF,MAAO;AAdxC,MAAAG,GAAAC;AAeD,QAAMC,KAAMD,KAAAD,IAAAH,EAAG,sBAAH,gBAAAG,EAAsB,MAAM,SAA5B,OAAAC,IAAoC,IAC1CE,IAAQN,EAAG;AACjB,MAAIO,IAAS;AACb,SAAAF,EAAI,QAAQ,CAACG,GAAWC,MAAU;AAC9B,UAAMC,IAAUJ,EAAM,cAAc,QAAQE,KAAa,GACnDG,IAAO,GAAGD,KAAWA,EAAQ,cAAcA,EAAQ,cAAc;AACvE,IAAIC,MACAJ,KAAUI,GACNF,IAAQJ,EAAI,SAAS,MACrBE,KAAU;AAAA,EAG1B,CAAK,GACMA;AACX;"}